{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { namehash } from '@ethersproject/hash';\nimport { useMemo } from 'react';\nimport { useSingleCallResult } from '../state/multicall/hooks';\nimport { isAddress } from '../utils';\nimport isZero from '../utils/isZero';\nimport { useENSRegistrarContract, useENSResolverContract } from './useContract';\nimport useDebounce from './useDebounce';\nimport useENSAddress from './useENSAddress';\n/**\n * Does a reverse lookup for an address to find its ENS name.\n * Note this is not the same as looking up an ENS name to find an address.\n */\n\nexport default function useENSName(address) {\n  _s();\n\n  var _resolverAddress$resu, _nameCallRes$result;\n\n  const debouncedAddress = useDebounce(address, 200);\n  const ensNodeArgument = useMemo(() => {\n    if (!debouncedAddress || !isAddress(debouncedAddress)) return [undefined];\n    return [namehash(`${debouncedAddress.toLowerCase().substr(2)}.addr.reverse`)];\n  }, [debouncedAddress]);\n  const registrarContract = useENSRegistrarContract(false);\n  const resolverAddress = useSingleCallResult(registrarContract, 'resolver', ensNodeArgument);\n  const resolverAddressResult = (_resolverAddress$resu = resolverAddress.result) === null || _resolverAddress$resu === void 0 ? void 0 : _resolverAddress$resu[0];\n  const resolverContract = useENSResolverContract(resolverAddressResult && !isZero(resolverAddressResult) ? resolverAddressResult : undefined, false);\n  const nameCallRes = useSingleCallResult(resolverContract, 'name', ensNodeArgument);\n  const name = (_nameCallRes$result = nameCallRes.result) === null || _nameCallRes$result === void 0 ? void 0 : _nameCallRes$result[0];\n  /* ENS does not enforce that an address owns a .eth domain before setting it as a reverse proxy \n     and recommends that you perform a match on the forward resolution\n     see: https://docs.ens.domains/dapp-developer-guide/resolving-names#reverse-resolution\n  */\n\n  const fwdAddr = useENSAddress(name);\n  const checkedName = address === (fwdAddr === null || fwdAddr === void 0 ? void 0 : fwdAddr.address) ? name : null;\n  const changed = debouncedAddress !== address;\n  return useMemo(() => ({\n    ENSName: changed ? null : checkedName,\n    loading: changed || resolverAddress.loading || nameCallRes.loading\n  }), [changed, nameCallRes.loading, checkedName, resolverAddress.loading]);\n}\n\n_s(useENSName, \"LM/F3tNX1vJuJvGJgzdfsNjYLNI=\", false, function () {\n  return [useDebounce, useENSRegistrarContract, useSingleCallResult, useENSResolverContract, useSingleCallResult, useENSAddress];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-main/src/hooks/useENSName.ts"],"names":["namehash","useMemo","useSingleCallResult","isAddress","isZero","useENSRegistrarContract","useENSResolverContract","useDebounce","useENSAddress","useENSName","address","debouncedAddress","ensNodeArgument","undefined","toLowerCase","substr","registrarContract","resolverAddress","resolverAddressResult","result","resolverContract","nameCallRes","name","fwdAddr","checkedName","changed","ENSName","loading"],"mappings":";;AAAA,SAASA,QAAT,QAAyB,qBAAzB;AACA,SAASC,OAAT,QAAwB,OAAxB;AAEA,SAASC,mBAAT,QAAoC,0BAApC;AACA,SAASC,SAAT,QAA0B,UAA1B;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AACA,SAASC,uBAAT,EAAkCC,sBAAlC,QAAgE,eAAhE;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AAEA;AACA;AACA;AACA;;AACA,eAAe,SAASC,UAAT,CAAoBC,OAApB,EAAoF;AAAA;;AAAA;;AACjG,QAAMC,gBAAgB,GAAGJ,WAAW,CAACG,OAAD,EAAU,GAAV,CAApC;AACA,QAAME,eAAe,GAAGX,OAAO,CAAC,MAAM;AACpC,QAAI,CAACU,gBAAD,IAAqB,CAACR,SAAS,CAACQ,gBAAD,CAAnC,EAAuD,OAAO,CAACE,SAAD,CAAP;AACvD,WAAO,CAACb,QAAQ,CAAE,GAAEW,gBAAgB,CAACG,WAAjB,GAA+BC,MAA/B,CAAsC,CAAtC,CAAyC,eAA7C,CAAT,CAAP;AACD,GAH8B,EAG5B,CAACJ,gBAAD,CAH4B,CAA/B;AAIA,QAAMK,iBAAiB,GAAGX,uBAAuB,CAAC,KAAD,CAAjD;AACA,QAAMY,eAAe,GAAGf,mBAAmB,CAACc,iBAAD,EAAoB,UAApB,EAAgCJ,eAAhC,CAA3C;AACA,QAAMM,qBAAqB,4BAAGD,eAAe,CAACE,MAAnB,0DAAG,sBAAyB,CAAzB,CAA9B;AACA,QAAMC,gBAAgB,GAAGd,sBAAsB,CAC7CY,qBAAqB,IAAI,CAACd,MAAM,CAACc,qBAAD,CAAhC,GAA0DA,qBAA1D,GAAkFL,SADrC,EAE7C,KAF6C,CAA/C;AAIA,QAAMQ,WAAW,GAAGnB,mBAAmB,CAACkB,gBAAD,EAAmB,MAAnB,EAA2BR,eAA3B,CAAvC;AACA,QAAMU,IAAI,0BAAGD,WAAW,CAACF,MAAf,wDAAG,oBAAqB,CAArB,CAAb;AAEA;AACF;AACA;AACA;;AACE,QAAMI,OAAO,GAAGf,aAAa,CAACc,IAAD,CAA7B;AACA,QAAME,WAAW,GAAGd,OAAO,MAAKa,OAAL,aAAKA,OAAL,uBAAKA,OAAO,CAAEb,OAAd,CAAP,GAA+BY,IAA/B,GAAsC,IAA1D;AAEA,QAAMG,OAAO,GAAGd,gBAAgB,KAAKD,OAArC;AACA,SAAOT,OAAO,CACZ,OAAO;AACLyB,IAAAA,OAAO,EAAED,OAAO,GAAG,IAAH,GAAUD,WADrB;AAELG,IAAAA,OAAO,EAAEF,OAAO,IAAIR,eAAe,CAACU,OAA3B,IAAsCN,WAAW,CAACM;AAFtD,GAAP,CADY,EAKZ,CAACF,OAAD,EAAUJ,WAAW,CAACM,OAAtB,EAA+BH,WAA/B,EAA4CP,eAAe,CAACU,OAA5D,CALY,CAAd;AAOD;;GA/BuBlB,U;UACGF,W,EAKCF,uB,EACFH,mB,EAECI,sB,EAILJ,mB,EAOJM,a","sourcesContent":["import { namehash } from '@ethersproject/hash'\nimport { useMemo } from 'react'\n\nimport { useSingleCallResult } from '../state/multicall/hooks'\nimport { isAddress } from '../utils'\nimport isZero from '../utils/isZero'\nimport { useENSRegistrarContract, useENSResolverContract } from './useContract'\nimport useDebounce from './useDebounce'\nimport useENSAddress from './useENSAddress'\n\n/**\n * Does a reverse lookup for an address to find its ENS name.\n * Note this is not the same as looking up an ENS name to find an address.\n */\nexport default function useENSName(address?: string): { ENSName: string | null; loading: boolean } {\n  const debouncedAddress = useDebounce(address, 200)\n  const ensNodeArgument = useMemo(() => {\n    if (!debouncedAddress || !isAddress(debouncedAddress)) return [undefined]\n    return [namehash(`${debouncedAddress.toLowerCase().substr(2)}.addr.reverse`)]\n  }, [debouncedAddress])\n  const registrarContract = useENSRegistrarContract(false)\n  const resolverAddress = useSingleCallResult(registrarContract, 'resolver', ensNodeArgument)\n  const resolverAddressResult = resolverAddress.result?.[0]\n  const resolverContract = useENSResolverContract(\n    resolverAddressResult && !isZero(resolverAddressResult) ? resolverAddressResult : undefined,\n    false\n  )\n  const nameCallRes = useSingleCallResult(resolverContract, 'name', ensNodeArgument)\n  const name = nameCallRes.result?.[0]\n\n  /* ENS does not enforce that an address owns a .eth domain before setting it as a reverse proxy \n     and recommends that you perform a match on the forward resolution\n     see: https://docs.ens.domains/dapp-developer-guide/resolving-names#reverse-resolution\n  */\n  const fwdAddr = useENSAddress(name)\n  const checkedName = address === fwdAddr?.address ? name : null\n\n  const changed = debouncedAddress !== address\n  return useMemo(\n    () => ({\n      ENSName: changed ? null : checkedName,\n      loading: changed || resolverAddress.loading || nameCallRes.loading,\n    }),\n    [changed, nameCallRes.loading, checkedName, resolverAddress.loading]\n  )\n}\n"]},"metadata":{},"sourceType":"module"}